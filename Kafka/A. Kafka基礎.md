#kafka
> [!info] 前言
>  當資訊系統大到一定程度時,往往會因為電腦硬體效能的關係，一台伺服器會漸漸無法負荷大量的流量，此時最簡單最直覺的方式就是增加伺服器來幫忙分擔流量，
>  這種系統統稱『分散式系統』

# 1. 分散式系統

## 分散式系統有什麼好處？

1. **故障容錯** - 某些伺服器節點發生故障時,不能影響整個系統的可用性,需要有效的備援機制，分散式系統因為同一種服務的伺服器有很多台，就能做到故障容錯。

2. **系統擴展性** - 當單機(或者當前數量的Server)無法應對龐大的訪問流量和數據處理需求時,可以馬上水平擴展(加入更多的伺服器)來幫忙分擔流量

3. **資料存儲/消費分離** - 生產者只管產生數據,消費者只管讀取處理數據, 解耦合提高系統靈活性。

雖然分散式的設計有好處，在這種分散式系統中,常常會遇到以下2個核心問題:

1. **可用性（Availability）**：大型分散式系統需要確保在面對各種故障情況時仍能提供服務。 這可能涉及容錯機制、備份和復原策略，以及合理的故障處理機制，確保即使部分元件或節點發生故障，系統仍能繼續運作

2. **資料一致性 (Consistency)** - 分散在多台伺服器上的數據需要保持一致,任何一個節點的修改都需要複製到其他節點，因為不管我們的『服務』用到多少台伺服器，對外部來說都是同一種服務，往A Server傳資料，要允許在B Server也可以取到同一筆資料，只因為他們是同一種『服務』
   
   > [!tldr] 延伸
>	通常有強一致性和最終一致性兩種模式，強一致性要求任何時間點對系統的查詢都會傳回最新的數據，而最終一致性則允許在一段時間內出現不一致，但最終會達到一致狀態

## Kafka 提供了什麼?

Kafka非常適合作為這種大型分散式系統的傳輸層,來有效解決上述核心問題:

1. 通過**分區(Partition)和複製(Replication)機制, 實現了資料的水平擴展和高可用性**。
   
2. 使用**日誌機制**來持久化和複製數據, **保證了資料的一致性**。
   
4. 生產者只需把數據發給Kafka, 無需關心消費端的情況。消費者可以根據需要從Kafka拉取數據進行處理，這行為稱為**Pull模式**，代表的是消費者主動從Kafka取資料，而非Kafka主動推送資料， 這也**解耦了兩者之間的依賴**，提高系統靈活性。
   
   > [!tldr] 延伸
>	有Pull模式 就有 Push模式，RabbitMQ走的就是Push模式的Broker


 通過Kafka作為分散式系統之間的數據溝通管道, 解耦了數據生產者和消費者,提高了整個系統的彈性和可擴展性。

# 2. Kafka 出現的角色

###     1. Topic(主題)
   Kafka走的是訂閱發布機制(publish–subscribe pattern)，就像是Youtube頻道的樣子，你訂閱了某個頻道，當這頻道有更新時，系統只會通知有訂閱的人，而Topic在這例子中對應的就是頻道名稱，由Producer發布並由Consumer訂閱和消費，
   但是是Consumer主動消費，而非Kafka主動推送資料過來。

###     2. Producer(生產者)
   資料產生者，負責不斷地向Kafka的Topic發送數據,每條數據在Kafka中被視為一條消息記錄(record)。Producer可以是各種應用程序,比如監控系統、網站伺服器日誌、工廠機台即時資料等。

###     3. Consumer(消費者) 
   Consumer則是向Kafka的Topic發出訂閱請求,並拉取(pull)訂閱主題的消息記錄進行處理的角色。  Consumer可以獨立運作,也可以組成消費者群組(Consumer Group),在群組內按分區劃分消費任務。
   
###     4. Broker
簡單來說就是Kafka節點之一，Broker負責接收、儲存、同步資料，每個Broker不僅為**Consumer**提供服務,還會與其他**Broker**通訊並進行資料備份,  形成一個分散式的集群

在Kafka中把這些資料稱作『Message』

概念圖如下：

![[image_589142173211625734253276.png]]